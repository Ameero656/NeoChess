# C++ Chess Project

## 1. Project Overview

This project is a C++ chess engine and game framework, designed with a focus on modern C++ practices, modularity, and extensibility. The primary intention is to enable the building of customized chess games, although the current implementation focuses on standard chess.

The project was originally implemented in C and has been re-architected into C++ to leverage object-oriented design principles, improve memory management, and enhance code clarity and maintainability.

**Current Features:**
* Standard chess game logic.
* Text-based visualization of the chessboard and game state.
* An evaluation engine to assess board positions.
* An AI that uses minimax search with alpha-beta pruning to find the best move.
* Multiple play modes: Human vs. Human, Human vs. AI, and AI vs. AI (configurable at startup).
* Basic implementation of special moves like castling, pawn promotion, and en passant.

## 2. Design Philosophy & C++ Transition

The conversion from C to C++ aimed to:
* **Embrace Object-Oriented Programming (OOP):** Key entities like the Board, Pieces, Game, and Players are represented as classes, encapsulating their data and behavior.
* **Modern C++ Practices:** Utilization of C++17 features, the Standard Library (STL) for containers and algorithms, and smart pointers for resource management.
* **Modularity:** The codebase is divided into logical components (core logic, player handling, AI, UI) with clear interfaces to promote separation of concerns and easier testing/maintenance.
* **Memory Safety:** `std::unique_ptr` is used extensively to manage the lifetime of dynamically allocated objects (especially chess pieces), significantly reducing the risk of memory leaks common with manual memory management in C. Copy and move semantics are carefully handled for classes managing resources.
* **Extensibility:** The design, particularly the polymorphic `Piece` hierarchy, aims to make it easier to introduce custom pieces, rules, or board configurations in the future.

## 3. Directory Structure

The project is organized as follows:

```

/chess\_project\_cpp/
|-- /src/                   \# Source code
|   |-- /core/              \# Core chess logic (Board, Piece, Game, Move, Position, types)
|   |-- /player/            \# Player logic (HumanPlayer, AIPlayer, base Player)
|   |-- /ai/                \# Artificial intelligence (EvaluationEngine)
|   |-- /ui/                \# User interface (TextDisplay)
|   |-- main.cpp            \# Main application entry point
|-- /build/                 \# Build directory (generated by CMake)
|-- CMakeLists.txt          \# CMake build script
|-- README.md               \# This file

```

## 4. Core Components (Classes & Responsibilities)

The core game logic resides in the `src/core/` directory.

### 4.1. `ChessTypes.h`
Defines fundamental enumerations used throughout the project:
* `enum class Color { WHITE, BLACK, NONE }`: Represents piece or player colors.
* `enum class PieceType { PAWN, ROOK, KNIGHT, BISHOP, QUEEN, KING, EMPTY }`: Defines the types of pieces.
* `enum class GameState { PLAYING, CHECK, CHECKMATE_WHITE_WINS, ... }`: Represents the current status of the game.
* `enum class PlayerType { HUMAN, AI }`: Distinguishes between human and AI-controlled players.
* `struct BoardDimensions { int rows, cols; }`: For potential customizable board sizes (defaults to 8x8).

### 4.2. `Position.h/.cpp`
* `struct Position { int row, col; }`: Represents a coordinate on the board.
* Provides methods for validation (`isValid`), comparison (`operator==`, `operator!=`), and conversion to/from algebraic notation (`toAlgebraic`, `fromAlgebraic`).

### 4.3. `Move.h/.cpp`
* `struct Move { Position from, to; PieceType promotionPiece; bool isCastling; bool isEnPassantCapture; }`: Represents a single move.
* Includes flags for special moves like pawn promotion, castling, and en passant.
* Provides a `toString()` method for logging or display.

### 4.4. `Piece.h/.cpp` (Abstract Base Class)
* Defines the interface and common properties for all chess pieces.
* **Data Members:** `color`, `position`, `type`, `value`, `hasMoved`, `pieceId`.
* **Key Virtual Methods:**
    * `virtual std::vector<Move> getPossibleMoves(const Board& board) const = 0;`: Pure virtual; derived classes implement specific move generation logic.
    * `virtual char getSymbol() const;`: Returns the character representation of the piece (e.g., 'P', 'p', 'R', 'r').
    * `virtual std::unique_ptr<Piece> clone() const = 0;`: Pure virtual; for creating deep copies of pieces, essential for board cloning.
* Managed by `std::unique_ptr` when placed on the `Board`.

### 4.5. Derived Piece Classes (`Pawn.h/.cpp`, `Rook.h/.cpp`, etc.)
* Inherit from `Piece`.
* Implement `getPossibleMoves()` according to standard chess rules for that piece type.
    * **Pawn:** Handles forward moves (one or two squares), diagonal captures, promotion (defaults to Queen, user input for HumanPlayer), and en passant logic (dependent on `Board` state like `enPassantTargetSquare` and `lastMove`).
    * **Rook, Bishop, Queen:** Implement sliding moves, checking for board boundaries and piece obstruction.
    * **Knight:** Implements L-shaped moves.
    * **King:** Implements single-square moves and castling intent (full castling validation occurs in the `Game` class).
* Implement `clone()` to allow for proper polymorphic copying.
* Override `getSymbol()` if necessary (though base implementation handles case based on color).

### 4.6. `Board.h/.cpp`
* Manages the chessboard and the pieces on it.
* **Data Members:**
    * `std::vector<std::vector<std::unique_ptr<Piece>>> grid;`: The 8x8 grid holding smart pointers to `Piece` objects.
    * `BoardDimensions dimensions;`
    * `const Move* lastMove;`: A non-owning pointer to the last move made (used for en passant). Set by the `Game` class.
    * Castling rights flags: `whiteCanCastleKingside`, etc.
    * `Position enPassantTargetSquare;`: The square a pawn can move to for an en passant capture.
* **Key Methods:**
    * `initializeDefaultSetup()`: Sets up the standard starting chess position.
    * `initializeEmptyBoard()`: Clears the board.
    * `getPieceAt(Position pos) const`: Returns a pointer to the piece at a given position.
    * `addPiece(std::unique_ptr<Piece> piece, Position pos)`: Adds a piece to the board.
    * `removePiece(Position pos)`: Removes a piece from a square, returning its `unique_ptr`.
    * `performMove(const Move& move)`: Executes a move on the board (updates piece positions, handles captures, promotion, castling rook movement). Assumes the move has already been validated for legality at the `Game` level.
    * `isSquareAttacked(Position square, Color attackerColor) const`: Checks if a given square is under attack by the specified color. Used for check detection.
    * Manages castling rights and en passant target square updates.
* Implements proper copy constructor, copy assignment (`operator=`), move constructor, and move assignment operators to handle the `grid` of `unique_ptr`s correctly (deep copying pieces by cloning).

### 4.7. `Game.h/.cpp`
* The central orchestrator of the chess game.
* **Data Members:**
    * `Board board;`
    * `std::unique_ptr<Player> player1`, `player2;`: Manages the two players.
    * `Color currentPlayerColor;`
    * `GameState gameState;`
    * `std::vector<Move> moveHistory;`
    * `int halfMoveClock;`, `int fullMoveCounter;`
* **Key Methods:**
    * Constructor takes `PlayerType` for each player.
    * `start()`: Initializes a new game.
    * `makeMove(const Move& move)`: The primary method for playing a move. It validates if the proposed move is legal (by calling `getLegalMoves`), updates the board, updates game state (half/full move clocks, en passant status), switches player, and then updates the overall `gameState` (check, checkmate, stalemate, etc.).
    * `getLegalMoves() const` / `getLegalMovesForColor(Color color) const`: Generates all valid moves for the specified player. This is a critical and currently performance-intensive method, as it simulates each pseudo-legal move on a temporary board copy to ensure the king is not left in check.
    * `isKingInCheck(Color kingColor) const`: Checks if the specified king is currently in check.
    * `updateGameState()`: Determines the current `GameState` based on checks, legal moves, and draw conditions (currently 50-move rule is basic).
    * `clone() const`: Provides a deep copy of the game state, essential for the AI's search algorithm.
* Manages turn progression and determines game end conditions.

## 5. Player Components (`src/player/`)

### 5.1. `Player.h/.cpp` (Abstract Base Class)
* Defines the interface for all player types.
* **Data Members:** `playerColor`, `name`.
* **Key Virtual Methods:**
    * `virtual Move getMove(const Game& game, const EvaluationEngine* engine = nullptr) const = 0;`: Pure virtual; derived classes implement how a move is chosen. Marked `const` as choosing a move should not alter the player's internal state.

### 5.2. `HumanPlayer.h/.cpp`
* Derived from `Player`.
* Implements `getMove()` by prompting the user for input via the console (e.g., "e2 e4").
* Handles parsing of algebraic notation and basic validation against the list of legal moves provided by the `Game` object, including prompting for pawn promotion piece.

### 5.3. `AIPlayer.h/.cpp`
* Derived from `Player`.
* Implements `getMove()` by delegating to an `EvaluationEngine` instance.
* Stores a `searchDepth` for its decision-making process.

## 6. AI Components (`src/ai/`)

### 6.1. `EvaluationEngine.h/.cpp`
* Responsible for evaluating board positions and finding the best move for the AI.
* `struct EvaluationResult { float score; Move bestMove; int nodesSearched; }`: Holds the outcome of an evaluation or search.
* **Key Methods:**
    * `float staticEvaluate(const Board& board, Color perspective) const;`: Calculates a score for the current board position from the given player's perspective. Current heuristics include:
        * Material balance.
        * Basic pawn structure (penalties for doubled/tripled pawns).
        * Basic center control.
        * *Limitations:* Lacks more advanced features like king safety, piece mobility, piece-square tables, passed pawns, etc. Contains a **FIXED BUG** related to an infinite loop in pawn structure calculation in earlier iterations.
    * `Move findBestMove(const Game& game, int depth) const;`: The main entry point for the AI. It initiates the search.
    * `EvaluationResult search(Game game, int depth, float alpha, float beta, bool isMaximizingTurn, Color originalPlayerColor) const;`: Implements the minimax algorithm with alpha-beta pruning.
        * Uses `game.clone()` to create copies of the game state for recursive exploration.
        * Uses `std::move()` to pass game state copies efficiently into recursive calls.
    * `std::vector<Move> orderMoves(const std::vector<Move>& moves, const Board& board) const;`: Sorts moves to improve alpha-beta pruning efficiency. Currently implements basic capture prioritization (MVV-LVA like).
* **Performance Notes:** The current AI's speed is heavily impacted by:
    * The cost of `Game::clone()` and `Board::clone()` being called at each search node.
    * The significant cost of `Game::getLegalMoves()`, which itself performs many board copies for validation. A "make/unmake move" approach on a single board instance passed by reference through the search tree would be a major optimization.

## 7. UI Components (`src/ui/`)

### 7.1. `TextDisplay.h/.cpp`
* Provides a simple text-based command-line interface for the game.
* **Key Methods:**
    * `displayBoard(const Board& board, const Move* lastMove = nullptr, const EvaluationResult* evalResult = nullptr) const;`: Renders the chessboard, highlighting the last move and optionally displaying evaluation information (score, best AI move, nodes searched) if provided.
    * `displayGameStatus(const Game& game) const;`: Shows current player, turn number, game state (Playing, Check, Checkmate, etc.).
    * `clearScreen()`: Basic console clearing.

## 8. Memory Management

* **`std::unique_ptr`:** Used for owning `Piece` objects within the `Board::grid` and for `Player` objects within the `Game` class. This ensures that piece and player objects are automatically deallocated when they are no longer needed (e.g., when a board is cleared or a game ends), preventing memory leaks.
* **RAII (Resource Acquisition Is Initialization):** This principle is followed through the use of smart pointers and STL containers.
* **Copy vs. Move Semantics:**
    * Classes like `Board` and `Game`, which manage resources (via `std::unique_ptr`), have their compiler-generated copy constructors and copy assignment operators implicitly deleted.
    * Custom `clone()` methods are provided for `Piece`, `Board`, and `Game` to perform semantic deep copies where necessary (e.g., for AI simulation).
    * Explicit move constructors and move assignment operators are defined for `Board` and `Game` to allow efficient transfer of resources (like the game state during AI search recursion using `std::move`).

## 9. Build System

* The project uses CMake (`CMakeLists.txt`) for building.
* **To Build:**
    1.  Ensure you have CMake and a C++17 compliant compiler (like GCC, Clang, or MSVC) installed.
    2.  Create a build directory (e.g., `mkdir build` in the project root).
    3.  Navigate into the build directory (`cd build`).
    4.  Run CMake to generate build files (`cmake ..`).
    5.  Compile the project (e.g., `make` on Linux/macOS, or build the generated solution in Visual Studio on Windows).
* The executable will typically be found in the build directory (e.g., `build/ChessGame` or `build/Debug/ChessGame.exe`).

## 10. Key Features & Game Flow

* **Game Setup:** `main.cpp` allows selection of player types (Human/AI) and AI depth.
* **Game Loop:** `main.cpp` contains the main game loop:
    1.  Display board and status.
    2.  Get move from the current player (`HumanPlayer` takes console input, `AIPlayer` uses `EvaluationEngine`).
    3.  Validate and make the move using `Game::makeMove()`.
    4.  Loop until game state is Checkmate, Stalemate, or another Draw condition.
* **Special Moves:**
    * **Pawn Promotion:** Handled in `Board::performMove()`. `HumanPlayer` prompts for choice. AI currently defaults to Queen (can be improved).
    * **Castling:** Move generation in `King::getPossibleMoves()`, path/check validation in `Game::getLegalMoves()`, execution in `Board::performMove()`. Castling rights are tracked in `Board`.
    * **En Passant:** Detection relies on `Board::enPassantTargetSquare` (set by `Game::makeMove()` after a two-square pawn push) and `Board::lastMove`. Execution logic is in `Board::performMove()`.

## 11. How to Run

1.  Build the project as described in section 9.
2.  Run the generated executable (e.g., `./ChessGame` or `ChessGame.exe`) from your terminal or command prompt, usually from within the build directory or wherever CMake places it.
3.  Follow the on-screen prompts to select player types and AI difficulty.
4.  For human players, enter moves in algebraic notation (e.g., "e2 e4").

## 12. Future Enhancements & Areas for Contribution

This project provides a solid foundation. Potential areas for future work include:

* **Graphical User Interface (GUI):** Replace or augment the text display with a graphical interface (e.g., using Qt, SFML, ImGui).
* **Advanced AI:**
    * **Sophisticated Evaluation:** Implement piece-square tables, detailed king safety analysis, mobility scoring, passed pawn evaluation, rook on 7th/open files, etc.
    * **Improved Search:**
        * **Make/Unmake Moves:** Crucial for performance. Modify `Board` and `Game` to support efficiently making and undoing moves on a single board instance passed by reference through the search, instead of `clone()` at every node.
        * **Quiescence Search:** To handle tactical sequences at leaf nodes more accurately.
        * **Transposition Tables (Zobrist Hashing):** To store and retrieve evaluations of previously seen positions.
        * **Iterative Deepening:** For better time management and move ordering.
        * More advanced move ordering (killer heuristic, history heuristic).
    * **Opening Books & Endgame Tablebases.**
* **Complete Draw Rule Implementation:**
    * **Threefold Repetition:** Requires storing and comparing position history (e.g., using FEN strings or Zobrist keys).
    * **Insufficient Material:** Implement checks for unwinnable endgames (e.g., K vs K, K+B vs K).
    * Accurate 50-move rule tracking.
* **Customizable Chess Games:**
    * Abstract rule sets further.
    * Allow dynamic loading or definition of custom pieces and their move patterns.
    * Support for different board sizes/shapes and initial setups.
* **Networking:** Implement multiplayer over a network.
* **Game Persistence:** Save and load games (e.g., using FEN for positions, PGN for full games).
* **Comprehensive Unit Testing:** Expand unit tests for all components.
* **Enhanced User Input/Commands:** Allow undoing moves, offering draws, resigning, etc.
* **Performance Profiling and Optimization:** Systematically identify and address bottlenecks.

This README should provide a comprehensive starting point. Good luck!